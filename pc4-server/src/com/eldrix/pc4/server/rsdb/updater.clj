(ns com.eldrix.pc4.server.rsdb.updater
  "A collection of tools to support updates to the legacy rsdb backend.

  rsdb v3 and earlier were monolithic applications with a single PostgreSQL
  backend.

  We may migrate away from PostgreSQL altogether, or at least, migrate to a
  different database schema, built upon immutable data. With unlimited time
  and resources, I'd build from the ground-up, and simply use legacy rsdb to
  pre-populate in read-only mode, with all users moving to v4 at the same time.

  However, we are going to have to run in parallel for some time with some users
  using v4, and others using v3, as functionality is ported across.

  That means we need to be able to upgrade legacy rsdb so we can continue to
  use as a backend for both v3 and v4 concurrently.

  This does not prevent future migration to a new data backend, perhaps
  datomic. But that cannot be at the same time as migrating to the v4
  front-end(s).

  The following reference data are stored:
  * SNOMED CT RF1 - in tables
        - t_concept
        - t_description
        - t_relationship
        - t_cached_parent_concepts
  * UK organisation data
        - t_health_authority
        - t_trust
        - t_hospital
        - t_surgery
        - t_general_practitioner
        - t_postcode

  This namespace provides functions that can take modern reference data sources
  and update the v3 backend so it may continue to run safely."
  (:require [clojure.core.async :as a]
            [com.eldrix.hermes.core :as hermes]
            [com.eldrix.hermes.snomed :as snomed]
            [next.jdbc.sql :as sql]
            [next.jdbc :as jdbc]))


(defn ec->cached-parent-concepts
  "Build a sequence of legacy cached parent concepts containing the keys
  :childConceptId and :parentConceptId suitable for building a legacy cache.
  Parameters:
  - ec : extended concept"
  [ec]
  (let [concept-id (get-in ec [:concept :id])
        isa-parents (get-in ec [:parentRelationships 116680003])]
    (map #(hash-map :childConceptId concept-id :parentConceptId %) isa-parents)))

(defn ec->rf1-concept [ec]
  {:concept_id           (get-in ec [:concept :id])
   :concept_status_code  (if (get-in ec [:concept :active]) 0 1) ;; 0 = "current" 1 = "retired"
   :ctv_id               ""
   :fully_specified_name (:term (first (filter snomed/is-fully-specified-name? (:descriptions ec))))
   :is_primitive         (if (snomed/is-primitive? (:concept ec)) 1 0)
   :snomed_id            ""})

(defn rf1-concept->vals [c]
  [(:concept_id c) (:concept_status_code c) (:ctv_id c) (:fully_specified_name c) (:is_primitive c) (:snomed_id c)])

(defn ec->rf1-descriptions
  [ec]
  (let [preferred (->> (:descriptions ec)
                       (remove snomed/is-fully-specified-name?)
                       (filter #(seq (:preferredIn %)))
                       first)]
    (map
      (fn [d]
        {:concept_id              (get-in ec [:concept :id])
         :description_id          (:id d)
         :description_status_code (if (:active d) 0 1)      ;; 0 = "current  1 = "non-current"
         :description_type_code   (cond
                                    (and (seq (:preferredIn d)) (snomed/is-fully-specified-name? d)) 3
                                    (= preferred d) 1
                                    :else 2)
         :initial_capital_status  (case (:caseSignificanceId d)
                                    ;; initial character is case-sensitive - we can make initial character lowercase
                                    900000000000020002 "1"
                                    ;; entire term case insensitive - just make it all lower-case
                                    900000000000448009 "0"
                                    ;; entire term is case sensitive - can't do anything
                                    900000000000017005 "1")
         :language_code           (:languageCode d)
         :term                    (:term d)})
      (:descriptions ec))))

(defn ec->rf1-relationships
  "Generate RF1 relationships from an extended concept.
  We cheat here by skipping most of the data, as it is not used in the legacy
  application. All we need is the source, the type and the destination.
  For referential integrity, all concepts will need to exist if these data
  are imported, and all existing relationships should be simply deleted before
  creating these new relationships.
  Warning: the relationship_id is generated by PostgreSQL as we do not use it."
  [ec]
  (->> (reduce-kv (fn [acc k v] (into acc (map #(vector k %) v))) [] (:directParentRelationships ec))
       (map (fn [[type-id target-id]]
              {:characteristic_type          0
               :refinability                 0
               :relationship_group           0
               :relationship_type_concept_id type-id
               :source_concept_id            (get-in ec [:concept :id])
               :target_concept_id            target-id}))))

(defn stream-extended-concepts
  "Return a channel on which all concepts will be returned."
  [hermes & {:keys [buf-n] :or {buf-n 50}}]
  (let [xf-extended-concept (map #(hermes/get-extended-concept hermes (:id %)))
        ch (a/chan buf-n xf-extended-concept)]
    (com.eldrix.hermes.impl.store/stream-all-concepts (.-store hermes) ch)
    ch))

(def upsert-concepts-sql
  (clojure.string/join " " ["insert into t_concept"
                            "(concept_id, concept_status_code, ctv_id, fully_specified_name, is_primitive, snomed_id)"
                            "values (?,?,?,?,?,?)"
                            "on conflict (concept_id) do update"
                            "set concept_status_code = EXCLUDED.concept_status_code,"
                            "ctv_id = EXCLUDED.ctv_id, fully_specified_name = EXCLUDED.fully_specified_name, is_primitive = EXCLUDED.is_primitive,"
                            "snomed_id = EXCLUDED.snomed_id"]))

(defn upsert-concepts
  "Insert or update a batch of concepts"
  [conn batch]
  (with-open [conn' (jdbc/get-connection conn)
              stmt (next.jdbc/prepare conn' [upsert-concepts-sql])]
    (next.jdbc/execute-batch! stmt batch)))


(defn update-concepts
  "Update the legacy rsdb concepts from the data available in hermes.
  * Streams all concepts from hermes
  * Maps to an RF1 representation
  * Turns into batches of values
  * Upserts each batch.
  Returns a count of concepts processed."
  [conn hermes & {:keys [batch-size] :or {batch-size 5000}}]
  (let [ch (stream-extended-concepts hermes)
        ch2 (a/chan 5 (partition-all batch-size))]
    (a/pipeline 4 ch2 (map (comp rf1-concept->vals ec->rf1-concept)) ch)
    (a/<!! (a/reduce (fn [acc batch] (+ acc (apply + (upsert-concepts conn batch)))) 0 ch2))))

(comment

  (def hermes (hermes/open "/Users/mark/Dev/hermes/snomed.db"))
  (hermes/get-extended-concept hermes 24700007)
  (require '[next.jdbc.connection])
  (def conn (next.jdbc.connection/->pool com.zaxxer.hikari.HikariDataSource {:dbtype          "postgresql"
                                                                             :dbname          "rsdb"
                                                                             :maximumPoolSize 10}))
  (sql/get-by-id conn :t_concept 104001 :concept_id {})
  (sql/update! conn :t_concept (ec->rf1-concept ec) {:concept_id (get-in ec [:concept :id])})



  (def ch (stream-extended-concepts hermes))
  (a/<!! ch)
  (def ch2 (a/chan 5 (partition-all 500)))
  (a/pipeline 4 ch2 (map (comp rf1-concept->vals ec->rf1-concept)) ch)
  (a/<!! ch2)
  (def ch3 (a/reduce (fn [acc batch] (+ acc (apply + (upsert-concepts conn batch))))
            0 ch2))
  (a/poll! ch3)
  (upsert-concepts conn [(ec->rf1-concept ec)])
  (map rf1-concept->vals [(ec->rf1-concept ec)])
  )
